/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*****************************************************************************
 *
 * Filename:
 * ---------
 * ul1_def.h
 *
 * Project:
 * --------
 *   WCDMA_Software
 *
 * Description:
 * ------------
 *   This file contains common typedef, definition prototypes exported by L1
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/
 
#ifndef _UL1_DEF_H
#define _UL1_DEF_H

/* auto add by kw_check begin */
#include "ul1_cnst.h"
#include "kal_general_types.h"
/* auto add by kw_check end */

/*-------- TGPS related definition  ----------------------*/
typedef enum _tgps_act_E
{
   TGPS_ACTIVATE,                            /* Activate the TGPS */
   TGPS_DEACTIVATE                           /* Deactivate the TGPS */
} tgps_act_E;

typedef enum _tg_mode_E
{
   TG_UL,                                    /* UL only */
   TG_DL,                                    /* DL only */
   TG_UL_DL                                  /* Both UL and DL */
} tg_mode_E;

typedef enum _tgmp_E
{
   TG_FDD_MEASURE,                       /* Inter-frequency measurement */
   TG_GSM_RSSI,                          /* GSM RSSI measurement */
   TG_GSM_BSIC_INIT,                     /* GSM initial BSIC */
   TG_GSM_BSIC_CNF,                      /* GSM BSIC confirm */
   TG_TGMP_UNDEFINED
} tgmp_E;

typedef enum _tg_method_E
{
   TG_PUNCT,                                 /* Puncturing. only for DL */
   TG_HLS,                                   /* Higher layer scheduling */
   TG_SF_2,                                  /* SF/2 */
   TG_NONE                                   /* None */
} tg_method_E;

typedef struct _tgps_info_T
{
   kal_uint8         tgpsi;                  /* TGPSI. 1 ~ 6 */
   kal_uint8         tgcfn;                  /* TGCFN. 0 ~ 255 */
   tgps_act_E        status;                 /* Action applied to TGPS */
   kal_bool          tgps_para_valid;        /* indicate if following parameter should be modifed */
   tgmp_E            purpose;                /* TGMP. TGPS purpose */
   tg_mode_E         mode;                   /* TG mode */
   tg_method_E       ul_method;              /* UL TG method */
   tg_method_E       dl_method;              /* DL TG method */
   kal_uint8         rpp;                    /* RPP. 0 or 1 */
   kal_uint8         itp;                    /* ITP. 0 or 1 */
   kal_uint8         dl_frame_type;          /* DL TG frame type. 0 : type A. 1 : type B */
   kal_uint8         sir1;                   /* DeltaSIR1. 0 ~ 30. true value is sir1/10 */
   kal_uint8         sir_after1;             /* DeltaSIRafter1. 0 ! 10. true value is sir_after1/10 */
   kal_uint8         sir2;                   /* DeltaSIR1. 0 ~ 30. true value is sir2/10 */
   kal_uint8         sir_after2;             /* DeltaSIRafter1. 0 ! 10. true value is sir_after2/10 */
   kal_uint16        tgprc;                  /* TGPRC. 0 ~ 511. 0 for infinity*/
   kal_uint8         tgsn;                   /* TGSN. 0 ~ 14 */
   kal_uint8         tgl1;                   /* TGL1. 1 ~ 14 slts */
   kal_uint8         tgl2;                   /* TGL2. 1 ~ 14 slts */
   kal_uint16         tgd;                    /* TGD. 15 ~ 270. 270 means TGD is undefed (only 1 TG) */
   kal_uint8         tgpl1;                  /* TGPL1. 1 ~ 144  */
   kal_uint8         tgpl2;                  /* TGPL2. 1 ~ 144  */
   kal_uint8         ident_abort;            /* N_IDENTIFY_ABORT. 1 ~ 128 */
   kal_uint8         reconf_abort;           /* Treconfirm_abort. 1 ~ 20. true value is divided by 2 */
} tgps_info_T;

typedef enum _tgps_status_E
{
   TGPS_ACTIVE,
   TGPS_DEACTIVE
} tgps_status_E;

typedef struct _tgps_status_T
{
   kal_uint8         tgpsi;                     /* TGPS index */
   kal_uint8         tgcfn;                     /* TGCFN. 0 ~ 255 */
   tgps_status_E     status;                    /* Status to be applied to TGPS */
} tgps_status_T;

typedef struct _tgps_status_info_T
{
   kal_uint8         num_tgps;                  /* # of TGPS status pattern */
   kal_int16         reconf_time;               /* TGPS reconfiguration CFN. -1 ~ 255. -1 means immediate */
   tgps_status_T     tgps_status[MAX_TGPS];     /* TGPS status information */
} tgps_status_info_T;


typedef struct _tgps_config_T
{
   kal_uint8         tgpsi;               /* tgpsi */
   tgmp_E            tgmp;                /* purpose of this tgpsi */
   tgps_status_E     status;	            /*tgps status at the activation time*/
} tgps_config_T;

typedef struct _p_tgps_config_T
{
   kal_int16         sfn;		            /* reconfig time of this pending tgps configuration*/
   kal_uint8         tgps_num;		      /* number of tgps in this pneding tgps */
   tgps_config_T     tgps[MAX_TGPS];	   /* tgps config (tgpsi, tgmp, status) */
} p_tgps_config_T;

typedef struct _tgps_config_by_tgmp_T
{
	kal_uint8		tgpsi;											/* tgpsi for the tgmp */
	kal_uint8      p_tgps_config_num;							/* pending tgps_config num of this tgpsi */
	kal_bool       c_tgps_config_valid;							/* existence of current tgps_config of this tgpsi, 
	                                                         if false, c_tgps_config is meaningless */
	tgps_config_T  c_tgps_config;									/* current tgps_config of this tgpsi */
	tgps_config_T  p_tgps_config[MAX_PENDING_TGPS_NUM];	/* pending tgps config of this tgpsi */
} tgps_config_by_tgmp_T;

typedef enum _tgps_time_relationship_E
{
   TGPS_BEFORE,
   TGPS_EQUAL,
   TGPS_AFTER
} tgps_time_relationship_E;

typedef enum _tgps_complete_status_E
{
   TGPS_COMPLETE_OR_INACTIVE,
   TGPS_NOT_COMPLETE
} tgps_complete_status_E;

typedef struct _tgps_complete_status_by_tgmp_T
{
   kal_int16      sfn;                          /*activation time or TGPS reconfiguration SFN, 
                                                range: -1-4095, -1 means immediate(only used in current tgps config)*/

   tgps_complete_status_E   tgps_complete_status;                               /* tgps complete status for that tgpsi*/
} tgps_complete_status_by_tgmp_T;

typedef struct _tgps_status_by_tgmp_T
{
   kal_uint8       tgmp_num;                                             /* num of valid tgmp in the structure */    
   tgmp_E         tgmp[MAX_TGMP_NUM];                            /* tgmp queried */
   kal_bool        status[MAX_TGMP_NUM];                          /* TRUE: if there is current or pending active and incompleted tgps for that tgmp */
} tgps_status_by_tgmp_T;

/*-------- PhyCH related definition  ----------------------*/
typedef struct _pich_drx_T
{
   kal_uint8         pch_drx;                /* DRX cycle length coefficient. 3 ~ 9 */
   kal_uint8         pi_num;                 /* # of PI per frame. 18, 36, 72, 144 */
   kal_uint8         pi;                     /* Paging Indicator index. */
   kal_uint16        sfn_po;                 /* SFN of the frame containing start of PICH for the first paging occasion. */
} pich_drx_T;

#ifdef __SMART_PAGING_3G_FDD__
typedef struct _pich_smartpaging_T
{
   kal_bool          support_repeat;        /* If true: RRCE has detected that current NW can support smart paging (has repeated paging pattern) */
   kal_uint16        sfn_po;                /* DRX parameters for PICH.(when smartpging active) */
} pich_smartpaging_T;
#endif

typedef enum _pich_reconfig_type_E
{
   PCH_MODIFY,                               /* traditionaly PCH modify */
   PCH_SMARTPAGE,                            /* to inform UL1 enable/disable SmartPaging*/   
} pich_reconfig_type_E;

typedef struct _pich_info_T
{
   kal_bool          sttd;                   /* If STTD is used. */
   kal_int8          cpich_tx_power;         /* CPICH TX power. -10~50 dBm */
   kal_int8          power_offset;           /* PICH power offset to CPICH. -10 ~ 5 dB */
   kal_uint8         ovsf;                   /* Channelization code. 0 ~ 255 */
   pich_drx_T        pich_drx;               /* DRX parameters for PICH. */
#ifdef __SMART_PAGING_3G_FDD__
   pich_smartpaging_T  smartpaging_info;
#endif
#ifdef __UMTS_R7__
   pich_drx_T        pich_drx_cycle2;               /* DRX parameters 2 for PICH. */
   kal_uint16        drx_cycle2_time;             /* if it's not 0. UL1 shall use pich_drx_2 for PICH receptin, else shall directly use pich_drx for PICH reception. 0~5120 ms */
#endif /* __UMTS_R7__ */
} pich_info_T;

typedef struct _ctch_drx_level1_T
{
   kal_uint8         m_tti;
   kal_uint8         start_off;              /* Offset of the start of first block set k. */
   kal_uint16        repe_period;            /* Block set repetition period. */
   kal_uint16        bmc_sm_period;          /*[R6] Period of BMC scheduling message (P)
                                               [Value] 1, 8, 16, 32, 64, 128, 256
                                               If this value is set to 1, UL1 will receive CTCH in all CTCH allocation.
                                               For R5 and R99, or for R6 but this field is not configured by the network, this value should be set to 1 */
} ctch_drx_level1_T;

typedef struct _ctch_drx_level2_T
{
//   kal_uint8         bs_mask[32];
//   kal_uint16        bs_mask_len;            /* 1 ~ 256 */
   kal_uint8         level2_bitmap[BMC_MAX_BITMAP_SIZE];
   kal_uint16        lenOfBitmap;
   kal_uint8         bitmapOffset;
   kal_uint16        sfnOfLastScheduleMsg;
} ctch_drx_level2_T;

typedef union _ctch_drx_level
{
   ctch_drx_level1_T drx_level1;             /* CTCH DRX Level 1 information. */
   ctch_drx_level2_T drx_level2;             /* CTCH DRX Level 2 information. */
} ctch_drx_level;

typedef struct _ctch_drx_T
{
   kal_bool          level1_Ind;             /* True: CTCH level 1 parameters is used. */
   ctch_drx_level    ctch_drx_level;         /* CTCH DRX level parameters */
} ctch_drx_T;

typedef union _pich_ctch_info
{
   ctch_drx_T        ctch_drx;               /* CTCH DRX information */
   pich_info_T       pich_info;              /* PICH information */
} pich_ctch_info;

typedef struct _sccpch_info_T
{
   kal_uint8         ssc;                    /* Secondary scrambling code. 0 ~ 15 */
                                             /* This value will not be used, if SCCPCH is used to carrying PCH */
                                             /* if the value is equal to 0, it means primary scrambling code is used */
   kal_bool          sttd;                   /* True if STTD is used */
   kal_bool          pilot_exit;             /* If pilot symbol exists */
   kal_bool          tfci_exit;              /* If TFCI is used. */
   kal_bool          fixed_pos_ind;          /* If Fixed or flexible position is used. True means Fixed */
   kal_uint16        timing_offset;          /* Frame boundary to P-CCPCH. 0 ~ 38144 by step of 256. */
   kal_uint16        sf;                     /* Spreading Factor. 4 ~ 256 */
   kal_uint16        ovsf;                   /* Channelization code. 0 ~ sf-1 */
} sccpch_info_T;

typedef enum _access_status_E
{
   AI_ACK,                                   /* Network ACK in AICH */
   AI_NACK,                                  /* Network NACK in AICH */
   AI_NOACK,                                 /* Network no response in AICH*/
   AI_ABORT,                                 /* Aborted by higher layer */
   AI_PARAMERROR,                            /* Access request without preliminary Data request */
   AI_NESTEDREQUEST                          /* Access request before previous one finished */
} access_status_E;

typedef struct _aich_info_T
{
   kal_int8          power_offset;           /* Power offset to CPICH. -22 ~ 5 dB */
   kal_uint8         ovsf;                   /* OVSF code. 0 ~ 255*/
   kal_bool          sttd;                   /* Indicate if STTD is used */
   kal_uint8         tx_timing;              /* AICH transmission timie. 0 or 1 */
} aich_info_T;

typedef struct _asc_T
{
   kal_uint8         avail_sig_start;              /* Available signature start index */
   kal_uint8         avail_sig_end;                /* Available signature end index */
   kal_uint8         assigned_subchannel;     /* Assigned subchannel number */
                                                             /* Bit0 represent bit b0, only 4 rightmost bit is valid */
} asc_T;

typedef struct _prach_info_T
{
   kal_uint16        min_sf;                 /* Min allowed SF. 32,64,128,256 */
   kal_uint8         punc_limit;             /* Puncturing limit. 40 ~ 100 */
   kal_uint8         asc_num;                /* # of valid ASC information in asc[]. 1 ~ 8 */
   kal_uint8         pream_psc;              /* Preamble scrambling code. 0 ~ 15 */
   kal_uint16        avail_signature;        /* Available signature. Bit string (16) */
                                             /* Bit0 represent signature 0 */
   kal_uint16        avail_subchannel;       /* Available subchannels. Bit string (12)*/
                                             /* Bit0 represent sub-channel 0 */
   asc_T             asc[MAX_ASC];           /* ASC information */
} prach_info_T;

typedef struct _prach_power_T
{
   kal_int8          max_tx_power;           /* Max allowed TX power. -50 ~ 33dBm */
   kal_int8          umts_power_class;       /* UE capability*/
   kal_int8          init_power_offset;      /* SUM of "P-CPICH TX power" and "constant value" */
                                             /* L1 will use this offste - CPICH_RSCP - UL_INTERFERENCE */
   kal_uint8         power_step;             /* Preamble power ramping step. 1 ~ 8dB */
   kal_uint8         retrans_max;            /* Max preamble retrans. 1 ~ 64 */
} prach_power_T;

typedef struct _ul_pc_info_T
{
   kal_uint8         pc_pream;               /* Power control Preamble. 0 ~ 7 frames */
   kal_uint8         pc_algo;                /* Power control algorithm. 1 or 2 */
   kal_uint8         tpc_step;               /* Power control step size. 1 or 2dB */
                                             /* This is only valid for pc_algo = 1 */
   kal_int16         dpcch_power_offset;     /* DPCCH initial power offset. -164 ~ 6 dBm */
} ul_pc_info_T;

typedef enum _sc_type_E
{
   SC_SHORT,                                 /* Short type scrambling code */
   SC_LONG                                   /* Long type scrambling code */
} sc_type_E;

typedef struct _ul_dpch_info_T
{
   ul_pc_info_T      ul_pc;                  /* UL power control info */
   sc_type_E         sc_type;                /* Type of scrambling code */
   kal_uint32        sc_code;                /* Scrambling code #. 0 ~ 16777215 */
   kal_uint8         ul_dpch_num;            /* # of UL DPDCH. 0 ~ MAX_ULDPCH */
   kal_uint16        min_sf;                 /* Min SF. 4,8,16,32,64,128,256 */
   kal_bool          tfci_exist;             /* Indicate if TFCI exists */
   kal_uint8         fbi_num;                /* # of FBI bits. 0, 1, 2 */
   kal_uint8         punc_limit;             /* Puncture limit. 40 ~ 100 in step 4 */
                                             /* The acture PM = punc_limit/100 */
#ifdef __UMTS_R7__
   kal_uint8         tpc_bit_num;                /* # of TPC bits. 2, 4 */
#endif /* __UMTS_R7__ */
} ul_dpch_info_T;

/*-------- TFS related definition  ----------------------*/
typedef enum _cc_type_T
{
   CC_NONE,
   CC_CONV12,
   CC_CONV13,
   CC_TURBO
} cc_type_T;

typedef struct _tfs_static_T
{
   kal_uint8         tti;                    /* TTI. # of frames, 1, 2, 4, 8 */
   cc_type_T         channel_coding;         /* Coding type */
   kal_uint8         rm_attr;                /* RM attribute */
   kal_uint8         crc_size;               /* # of CRC bits. 0,8,12,16,24 */
} tfs_static_T;

typedef struct _tfs_dyn_T
{
   kal_uint8         tb_num;                 /* # of TB */
   kal_uint16        tb_size;                /* # of bibts in a TB */
} tfs_dyn_T;

typedef struct _tfs_T
{
   kal_uint8         tf_num;                 /* # of TF in this TFS */
   tfs_dyn_T         tfs_dynamic[MAXTF];      /* TFS dynamic part */
   tfs_static_T      tfs_static;             /* TFS static part */
} tfs_T;

typedef enum _tx_diversity_E
{
   DL_TX_NONE =0,                              /* No TX diversity */
   DL_TX_STTD =1,                              /* STTD */
   DL_TX_CLM1 =2,                              /* Closed loop mode 1 */
   DL_TX_CLM2 =3                               /* Closed loop mode 2 */
   
} tx_diversity_E;

typedef enum _cws_len_E
{
   SSDT_LONG,                                 /* Long code word */
   SSDT_MEDIUM,                              /* Medium code word */
   SSDT_SHORT,                               /* Short code word */
   SSDT_OFF                                 /* SSDT is off */

} cws_len_E;

typedef struct _ssdt_conf_T
{
   kal_uint8         s_field;                /* # of s bits. 1 or 2 */
   cws_len_E         cws_len;                /* Code word set length */
} ssdt_conf_T;

typedef enum _dpch_type_E
{
   DPCH_TYPE = 0,
   FDPCH_TYPE = 1,
   /* __UMTS_R7__ BEGIN */
   NO_DPCH_TYPE
   /* __UMTS_R7__ END */
} dpch_type_E;

typedef struct _dl_dpch_rla_T
{
   kal_uint8         dpc_mode;               /* DL Power control mode. 0 or 1 or 2 */
   kal_uint8         pilot_power_offset;     /* Ppilot - Pdpdch. 0 ~ 24dB */ /*[R6] For F-DPCH, UL1 doesn't care this value  */
   kal_uint16        sf;                     /* SF. 4,8,16,32,64,128,256,512 */ /*[R6] For F-DPCH, UL1 doesn't care this value   */
   kal_bool          fixed_pos;              /* Fixed or flexible position. True = Fixed */ /*[R6] For F-DPCH, UL1 doesn't care this value   */
   kal_bool          tfci_exist;             /* Indicate if TFCI exist */ /* [R6] For F-DPCH, UL1 doesn't care this value   */
   kal_uint8         pilot_num;              /* # of pilot bits. 2,4,8,16 */ /* [R6] For F-DPCH, UL1 doesn't care this value   */
   kal_uint8         tgps_num;               /* # of TGPS in the list. 0 ~ 6 */
   tgps_info_T       tgps_info[MAX_TGPS];    /* TGPS list */
   tx_diversity_E    tx_diversity;           /* TX diversity mode */ /* [R6] For F-DPCH, UL1 doesn't care this value   */
   ssdt_conf_T       ssdt_conf;              /* SSDT configuration */ /* [R6] For F-DPCH, UL1 doesn't care this value   */
   kal_int32         doff;                   /* Default DPCH offset value. -1 ~ 306688 */
                                             /* -1 is an invalid value */
                                             
   dpch_type_E       dpch_type;              /* [R6] DPCH or F-DPCH, for R5 and previous version, this value should be DPCH_TYPE */
                                             /* This value should be consistent with the dpch_type field in dl_dpch_rl */
   kal_uint8         tpc_target;             /* [R6] F-DPCH only, range: 1~10, the actual TPC command error rate target is tpc_target/100 */                                             
} dl_dpch_rla_T;

typedef struct _dldpch_code_T
{
   kal_uint8         ssc;                    /* Scrambling code # for this code channel */
                                             /* 0 ~ 15. 0 for "the same scrambling code for the P-CPICH */
   kal_uint16        sf;                     /* 4,8,16,32,64,128,256,512 */
   kal_uint16        ovsf;                   /* OVSF code. 0 ~ SF-1 */
   kal_bool          sc_change;              /* True : Changed scrambling code is used */
} dldpch_code_T;

typedef struct _dl_dpch_rl_T
{
   kal_uint16        psc;                    /* Primary scrambling code. 1 ~ 511 */
   kal_bool          sttd;                   /* Indicate if STTD is used for P-CPICH for this RL */
                                             /* If the value of tm is not equal to -1, UL1 will use this value */
                                             /* If the value of tm is equal to -1, UL1 will not use this value */
   kal_bool          sttd_valid;             /* To judge if sttd value can be used by UL1 when doing SCS */                                
   kal_int32         tm;                     /* Cell boundary to LST. -1 ~ 38400*8-1 */
   kal_int16         off;                    /* FN offset. -1 ~ 4095 : -1 means unknown timing */
   kal_uint16        dpch_offset;            /* DPCH frame offset to P-CPICH of this cell */
   kal_bool          pcipch_usage;           /* Indicate if P-CPICH can be used for channel estimation */
                                             /* KAL_TRUE means P-CPICH could be used */
   kal_int8          scpich_ssc;             /* Scrambling code of S-CPICH. */
                                             /* -1 ~ 15. 0 means use primary scramblign code */
                                             /* -1 means there is not S-CPICH */
   kal_uint8         scpich_ovsf;            /* OVSF code. 0 ~ 255 */
   kal_bool          tx_diversity_disable;   /* Indicate if TX diversity is used */ /* [R6] For F-DPCH, UL1 doesn't care this value   */
                                             /* True means TX diversity is disabled. */ /* [R6] For F-DPCH, UL1 doesn't care this value   */
   kal_uint8         closedlooptimingadj_mode;              /* 0 : CLTD timing adjust mode 0 */ /* [R6] For F-DPCH, UL1 doesn't care this value   */
                                             /* 1 : CLTD timing adjust mode 1 */
   kal_uint8         ssdt_id;                /* 0 ~ 8. 1 for 'A'. 8 for not applicable*/
   kal_uint8         tpc_index;              /* TPC combination index. 0 ~ 5 */
   kal_int8          tpc_power_offset;       /* Power offset between TPC and DPDCH,-1 means INVALID, range 0~24 dB (actual 0:0.25:6) [R5 only] */
                                             /* [R6] For F-DPCH, UL1 doesn't care this value   */

   /* [R6] F-DPCH: dl_dpch_num must be 1 and the index of the F-DPCH info must be 0 in dl_dpch_info list */
   kal_uint8         dl_dpch_num;            /* # of DPDCH on the RL */
   dldpch_code_T     dl_dpch_info[MAX_DLDPCH];  /* Information for each code channel */

   dpch_type_E       dpch_type;              /* [R6] DPCH or F-DPCH, for R5 and previous version, this value should be DPCH_TYPE */
                                             /* This value should be consistent with the dpch_type field in dl_dpch_rla */
   kal_uint8         fdpch_slot_format;      /* [R7]  F-DPCH only, range: 0~9. For R6 and previous version, this value should be 0 */                                                    
   kal_bool          fdpch_sttd_ind;         /* [R6]  F-DPCH only, TRUE when STTD is used. FALSE, otherwise */   

   kal_bool          hsdsch_serving_rl_ind;  /* [R5]  The value "TRUE" indicates that this radio link is the serving HS-DSCH radio link. FALSE, otherwise */   
   kal_bool          edch_serving_rl_ind;    /* [R6]  The value "TRUE" indicates that this radio link is the serving E-DCH radio link. FALSE, otherwise */     
} dl_dpch_rl_T;

typedef struct _dl_establish_T
{
   kal_uint8         t312;                   /* T312 */
   kal_uint16        n312;                   /* N312 */
   kal_uint8         n313;                   /* N313 */
   kal_uint8         t313;                   /* T313 */
   kal_uint16        n315;                   /* N315 */
} dl_establish_T;

#ifdef __UMTS_R7__
/* [R7] Determine whether UL1 need to store HS-SCCH order when release DCH channel */
typedef enum _dpch_release_type_E
{
   DCH_RELEASE=0,            /* Don't need to store HS-SCCH order */ 
   DCH_TRHHO_RELEASE,            /* Need to store HS-SCCH order */
   DCH_TRHHO_REVERT_RELEASE,            /* Don't need to store HS-SCCH order */
   DCH_TMHHO_RELEASE,            /* Need to store HS-SCCH order */
   DCH_TMHHO_REVERT_RELEASE,            /* Don't need to store HS-SCCH order */
   DCH_IRAT_RELEASE,            /* Need to store HS-SCCH order */
   DCH_ALL_RL_TIMING_MODIFY_RELEASE            /* Need to store HS-SCCH order */
} dpch_release_type_E;
#endif  /* __UMTS_R7__ */

/*-------- TFCS related definition  ----------------------*/
typedef struct _sig_gain_T
{
   kal_uint8         beta_c;                 /* Bc. 0 ~ 15 */
   kal_uint8         beta_d;                 /* Bd. 0 ~ 15 */
   kal_int8          ref_tfc_id;             /* Reference TFC ID. -1 ~ 3. */
                                             /* 0 ~ 3 : This TFCI is a referenced id for other computed TFC. */
                                             /* -1 : It is an invalid value. Means it will not be referenced by other TFC. */
} sig_gain_T;

typedef union _gain_factor
{
   kal_int8          computed_gain_id;          /* For computed gain factor using reference TFC id. 0 ~ 3 */
   sig_gain_T        sig_gain;                  /* The signaled gain factor. */
} gain_factor;

typedef struct _ul_dpch_tfc_T
{
   kal_uint8         tfi_list[MAX_TRCH_NUM];    /* The list of TFI for this TFCI for UL DCH TrCH */
   kal_bool          sig_gain_ind;              /* True: Gain factor is siganled. False: Gain factor is computed from reference TFCI */
   gain_factor       gain_factor;               /* Gain factor */
} ul_dpch_tfc_T, ul_tfc_T;
//} ul_dpch_tfc_T;

typedef struct _rach_tfc_T
{
   kal_uint8         tfi_list;                  /* The list of TFI for this TFCI. The number of TrCH for PRACH is 1. */
   kal_bool          sig_gain_ind;              /* True: Gain factor is siganled. False: Gain factor is computed from reference TFCI */
   kal_int8          msg_pwr_offset;            /* Power offset between the last preamble and the control part of RACH */
   gain_factor       gain_factor;               /* Gain factor */
} ul_rach_tfc_T;

typedef struct _dl_tfc_T
{
   kal_uint8         tfi_list[MAX_TRCH_NUM];    /* The list of TFI for this TFCI for DL TrCH */
} dl_tfc_T;

/*-------- TrCH related definition  ----------------------*/

#if 0	//Modify by Anthony Chin, for UL1D's convenience to maintain DB
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
typedef struct _trch_T
{
   kal_uint8         trch_id;                   /* TrCH ID 1 ~ 32 */
   kal_uint8         bit_offset;                /* Bit offset. 0 ~ 7 */
   tfs_T             tfs;                       /* TFS of this TrCH */
   kal_int8          target_bler;               /* Diving the value of this field to 10 get the real BLER. -63 ~ 0 */
}  trch_T, 
   ul_rach_trch_T, 
   ul_dch_trch_T, 
   dl_fachpch_trch_T,
   dl_dch_trch_T;
#endif

/*-------- CCTrCH related definition  ----------------------*/
typedef enum _cctrch_type_E
{
   CCTRCH_UL_RACH,                              /* UL RACH CCTrCH */
   CCTRCH_UL_DCH,                               /* UL DCH CCTrCH */
   CCTRCH_DL_DCH,                               /* DL DCH CCTrCH */
   CCTRCH_DL_PCH,                               /* DL PCH CCTrCH */
   CCTRCH_DL_FACH,                              /* DL FACH CCTrCH */
   CCTRCH_DL_BCH,                               /* DL BCH CCTrCH */
   CCTRCH_DL_FDPCH,                             /* DL FDPCH, only for UL1 use */
   /* __UMTS_R7__ BEGIN */
   CCTRCH_DL_EPCH,                              /* DL EPCH CCTrCH */
   /* __UMTS_R7__ END */
   /* __UMTS_R8__ BEGIN */
   CCTRCH_UL_EDCH                               /* UL EDCH CCTrCH */
   /* __UMTS_R8__ END */
} cctrch_type_E;

typedef struct _FACH_PCH_Info_T
{
   kal_uint16        psc;                    /* Primary scrambling code */
   kal_bool          sttd;                   /* Indicate if STTD is used for P-CPICH for this RL */
                                             /* If the value of tm is not equal to -1, UL1 will use this value */
                                             /* If the value of tm is equal to -1, UL1 will not use this value */
   kal_int16                     rscp;                      /* Serving cell RSCP. Range: -464 ~ -100 means (-116 ~ -25 )dBm in 0.25 dB step*/											 
   sccpch_info_T     sccpch_info;            /* Physical channel for PCH/FACH to be carried over */
   kal_bool          sccpch_optimization;    /* True if FACH and PCH use the same S-CCPCH. valid only for configuring CTCH */
   kal_uint16        tfc_num;                /* # of TFC in TFCS */
   dl_tfc_T          tfcs[MAX_DL_TFC];       /* TFCS */
   kal_uint8         active_dl_trch_list;    /* Active TrCHs by bit string. MSB is the lowest numbered TrCH ID */
   kal_uint8         trch_num;               /* # of TrCHs carried on this CCTrCH */
   dl_fachpch_trch_T trch_list[MAXFACHPCH];  /* List of TrCHs carried on this CCTrCH */
   kal_bool          pich_ctch_valid;        /* True means "pich_ctch_info" is valid. */
   pich_ctch_info    pich_ctch_info;         /* PICH or CTCH information */
} FACH_PCH_Info_T;

/*-------- BCH related definition  ----------------------*/
typedef struct _sib_info_T
{
   kal_uint8      seg_count;                    /* SEG_COUNT   1 ~ 16 */
   kal_uint16     sib_rep;                      /* SIB_REP     2^2 ~ 2^12 */
   kal_uint16     sib_pos;                      /* SIB_POS     0 ~ sib_rep-2 */
   kal_uint8      sib_off[MAX_SIB_SEG_COUNT];   /* SIB_OFF     2 ~ 32 The # of elements of this field is equal to seg_count-1 */
} sib_info_T;

typedef enum _bch_priority_E
{
   BCH_PRIOHIGH,                                /* Priority High */
   BCH_PRIOMEDIUM,                              /* Priority Medium */
   BCH_PRIOLOW                                  /* Priority Low */
} bch_priority_E;

/*------- PHY_POST_TX_IND related ---------*/
typedef struct _tPhyPostTxMemInfo
{
    kal_uint8    RbId;
    kal_uint8    *pContainer;
}tPhyPostTxMemInfo;

typedef struct _tPhyPostTxElement
{
    kal_uint8    Num;
    tPhyPostTxMemInfo    TxMemInfo[MAX_UL_TB];
#if defined(__GEMINI_MONITOR_PAGE_DURING_TRANSFER__) && defined(__GEMINI_GSM__) && defined(__UMTS_RAT__)
    kal_bool          is_tx_suspend;          /* This flag is only used for ULDCH when Gemini2.0. For RACH, this flag is always false.
                                                It indicates if there is SIM2 gap in the minTTI period of the released ul data, and UL1D will set this flag. */
    kal_uint8         cfn;                    /* This value is only used for ULDCH when Gemini2.0. 
                                                It indicates the cfn value that UL1C gets the ul data from UMAC. */
#endif
}tPhyPostTxElement;

typedef enum _tPhyPostTxType
{
    POST_TX_RACH,
    POST_TX_DCH
}tPhyPostTxType;

/*-------- Data related definition  ----------------------*/
typedef struct _dlTrchData
{
   kal_bool          valid_fpch; /* Raymond,20070327 Eric/Anthony add this, already notify UMAC */
   kal_bool          is_dual_TF; /* Andrew/Sean: For MAC to identify BTFD_DUAL_TF TrCh */
   kal_int8          crc_status; /* Jay: For DUAL-TF TrCH power control*/
   kal_uint8         trchId;                    /* TrCH ID */
   kal_uint16        tb_size;                   /* TB size in bit. 0 ~ 4992 */
   kal_uint16        num_tb;                    /* # of TB. 0 ~ 512 */
} dlTrchData;

typedef struct _ulTrchData
{
   kal_uint8         trchId;                    /* TrCH ID */
   //kal_uint8         rm;                        /* RM attribute. 0 ~ 255 */
   kal_uint16        tb_size;                   /* TB size in bit. 0 ~ 4992 */
   kal_uint16        num_tb;                    /* # of TB. 0 ~ 512 */
} ulTrchData;

/*-------- Measurement related definition  ----------------------*/
typedef struct _preferred_cell_list_T
{
   kal_uint8         uarfcn_index;              /* Frequency index */
                                                /* Freq. array is contained in Frequency scan message */
   kal_uint16        psc;                       /* Primary Scrambling code */
} preferred_cell_list_T;

typedef enum _measured_type_E
{
   INTRA_FREQENCY_MEASURED,
   INTER_FREQENCY_MEASURED,
   FREQ_SCAN_DETECTED,
   SERVING_ONLY
} measured_type_E;


typedef enum _cell_type_E
{
   MONITORED,
   DETECTED,
   SPECIFIC_CELL_SEARCH,
   MONITORED_CELL_FOUND,
   DETECTED_CELL_FOUND
} cell_type_E;

typedef enum _meas_status_E
{
   MS_INCLUDED,
   MS_NOTINCLUDED
} meas_status_E;

typedef enum _meas_tm_off_type_E
{
   TM_OFF_RST,
   TM_OFF_DCH,
   TM_OFF_COMMON,
   TM_OFF_NA
}meas_tm_off_type_E;

typedef struct _measured_cell_T
{
   kal_bool          sttd;                      /* Indicate if STTD is used */
   kal_int16         ec_no;                     /* Ec/No. Range: -100~0 means (-25~0) dB in 0.25 dB step */
   kal_int16         rscp;                      /* RSCP. Range: -464 ~ -100 means (-116 ~ -25 )dBm in 0.25 dB step*/
   kal_uint16        psc;                       /* Primary scrambling code */
   kal_uint16        freq;                      /* DL UARFCN */
   meas_tm_off_type_E   tm_off_type;        /*Indicate which field is applicable in this report*/
   kal_int16         sfn;                       /* SFN in BCH. -1 ~ 4095 : -1 means unknown SFN */
   kal_int16         off;                       /* FN offset. -1 ~ 4095 : -1 means unknown timing */
   kal_int32         tm;                        /* Cell boundary. -1 ~ 38400*8-1 : -1 means unknown timing*/
   kal_uint32        meas_sfn_diff;                     /* SFN_SFN difference in chips*/     
   meas_status_E     meas_status;               /* Indicate whether this cell is measured in this time */
   cell_type_E       cell_type;                 /* AS, MS or DS cell */
} measured_cell_T;

typedef enum _meas_type_E
{
   MT_INTRA_FREQ,                               /* Intra-frequency measurement */
   MT_INTER_FREQ,                               /* Inter-frequency measurement */
   MT_GSM_RAT                                   /* GSM-RAT measurement */
} meas_type_E;

typedef enum _sfn_priority_E
{
   SFN_HIGH,
   SFN_MEDIUM,
   SFN_LOW,
   SFN_OFF
} sfn_priority_E;

typedef struct _meas_spec_T
{
   kal_bool          ds_meas;                   /* Indicate if measure on detected set*/
   kal_bool          ds_sfn;                    /* Indicate if reading SFN of detected set */
   kal_int8          nc_nbr_dch;                /* # of best cells to read SFN in DCH. -1 ~ 32
                                                   -1 means L1 should not read SFN for any cell
                                                   0 means L1 should read SFN for cells which have stronger CPICH measurement
                                                   Other values means L1 should read FN for nc_nbr_dch cells from active set, monitored set and detected set.
                                                 */
   sfn_priority_E    serving_prio;              /* The priority of reading SFN of cells in active set.
                                                   Only used when L1 is in DCH state and nc_nbr_dch > 0 */
   sfn_priority_E    monitor_prio;              /* The priority of reading SFN of cells in monitored set.
                                                   Only used when L1 is in DCH state and nc_nbr_dch > 0 */
   sfn_priority_E    detect_prio;               /* The priority of reading SFN of cells in detected set.
                                                   Only used when L1 is in DCH state and nc_nbr_dch > 0 */
   kal_uint8         nc_nbr_rach;               /* # of best cells to read SFN in non-DCH state. 0 ~ 32 */
} meas_spec_T;

#ifdef __UMTS_R8__
typedef enum _higher_prio_search_support_E   /* [Rel8][Absolute Priority Search] absolute priority search type */
{
   REGULAR_MEAS_ONLY,
   HIGHER_PRIORITY_ONLY,
   HIGHER_PRIORITY_AND_REGULAR_MEAS
}higher_prio_search_support_E;
#endif

typedef struct _cell_info_list_T
{
   kal_uint8         freq_index;                /* UARFCN index */
   kal_uint16        psc;                       /* Primary scrambling code */
   kal_bool          sttd;                      /* Indicate if STTD is used */
   kal_bool          read_sfn_ind;              /* Indicate if read SFN */
   kal_int16         ref_timing;	            /* Cell boundary. -1 ~ 38400-1 : -1 means unknown timing*/   
   kal_bool          ref_timing_sib;           /* Indicate if the reference timing comes from SIB or Meas. Control */   
   kal_int32         tm;                        /* Cell boundary. -1 ~ 38400*8-1 : -1 means unknown timing*/
   kal_int16         off;                       /* FN offset. -1 ~ 4095 : -1 means unknown timing */
 #ifdef __UMTS_R8__  
   higher_prio_search_support_E prio_search_control; /* [Rel8] Higher priority search control */
#endif
} cell_info_list_T;

typedef enum _event_cond_E
{
   COND_ABOVE,                                  /* Above threshold */
   COND_ABOVE_EQUAL,                            /* Above or equal to threshold */
   COND_BELOW,                                  /* Below threshold */ 
   COND_BELOW_EQUAL,                            /* Below or equal to threshold */
   COND_EVENT_6C,                               /* [R6] Reporting event 6C: The UE Tx power reaches its minimum value */
   COND_EVENT_6D                                /* [R6] Reporting event 6D: The UE Tx power reaches its maximum value */
} event_cond_E;

typedef struct _meas_event_T
{
   kal_uint8         event_id;                  /* Measurement event ID */
   kal_int16         threshold;
   kal_uint16        delay;                     /* Time to Triggered. 0 ~ 500 frames */
   event_cond_E      condition;                 /* Event triggered condition */
} meas_event_T;

typedef struct _rl_meas_result_T
{
   kal_uint8         rl_status;                 /* RL status */
                                                /* 0 : Not detected */
                                                /* 1 : Detected not used */
                                                /* 2 : Detected and demodulated */
   kal_uint16        psc;                       /* Scrambling code of this RL */
   kal_uint32        time_diff;                 /* RX-TX Timd diff. 0 ~ 38400*8-1 */
} rl_meas_result_T;

typedef enum _meas_act_E
{
   MEAS_UNCHANGE,                               /* Unchange a cell list */
#ifndef __MTK_UL1_FDD__ /* 20080305: For Venus, still use old I/F */
   MEAS_MODIFY,                                 /* Modify an existed cell list */
#endif
   MEAS_DELETE,                                 /* Delete an existed cell list */
   MEAS_UPDATE                                  /* Update the configuration of an existed cell list */
} meas_act_E;

typedef enum _triggering_cause_E
{
   REGULAR_REPORT,
   ONE_SHOT_MEASUREMENT,
   T_RESELECTION_EXPIRY
} triggering_cause_E;

typedef struct _supplementary_meas_parameter_T
{
   kal_bool                   intra_meas_one_shot_ind;   /* When intra-F cell list is updated,to notify if UL1 needs to do one-shot measurement on intra-F or not */
   kal_bool                   inter_meas_one_shot_ind;   /* When inter-F cell list is updated,to notify if UL1 needs to do one-shot measurement on inter-F or not */
} supplementary_meas_parameter_T;

typedef struct _supplementary_report_info_T
{
   triggering_cause_E	triggering_cause;   /* The triggering cause of this meas tick */
   kal_bool  		evaluate_req;         /* To notify if L3 need to trigger cell evaluattion */
#ifdef __UMTS_R7__
   kal_bool                      is_cycle2;                          /* Indicate whether the current DRX is cycle2 or not */
#endif  /* __UMTS_R7__ */
} supplementary_report_info_T;

/*-------- FACH MO related definition  ----------------------*/
typedef struct _fach_mo_info_T
{
   kal_uint8         n;                         /* # of frames in max TTI. 1,2,4,8 */
   kal_uint8         k;                         /* MO cycle length coefficient. M_REP=2^k */
   kal_bool          inter_freq_ind;            /* Indicate if inter-frequency meas in MO */
   kal_bool          inter_rat_ind;             /* Indicate if inter-RAT meas in MO */
   kal_bool          inter_freq_cell_exist; /* Indicate if inter-freq cell in BA lsit is existed */
   kal_bool          inter_rat_cell_exist; /* Indicate if inter-rat cell in BA list is existed */
   kal_uint16        start_off;                 /* C_RNTI % M_REP. 0 ~ 4095 */
} fach_mo_info_T;

/*-------- Operation-Mode related definition  ----------------------*/
typedef enum _mode_type_E
{
   OM_SINGLE,                                   /* Single Mode */
   OM_DUAL                                      /* Dual Mode */
} mode_type_E;

typedef enum _rat_type_E
{
   UL1_RAT_FLIGHT,                                  /* Flight mode */
   UL1_RAT_UMTS,                                    /* UMTS active */
   UL1_RAT_GSM                                      /* GSM active */
} rat_type_E;

/*-------- Message(Primitive) related definition  ----------------------*/
typedef enum _dch_setup_msg_type_E
{
   DCH_SETUP,                                   /* Used when DCH is established first time */
   DCH_TRHHO,                                   /* Used when timing reinitialized hard hand over */
   DCH_TRHHO_REVERT,	                        /* Used when timing reinitialized HHO revert */
   DCH_TMHHO,                                   /* Used when timing maintained hard hand over */
   DCH_TMHHO_REVERT,                            /* Used when timing maintained HHO revert */   
   DCH_IRAT_REVERT,                             /* Used when Inter-RAT HHO revert */
   DCH_ALL_RL_TIMING_MODIFY                     /* Used when all dpch rl timing offset is modified.*/
} dch_setup_msg_type_E;


typedef enum _dch_modify_msg_type_E
{
   DCH_RECONFIG,                                   /* Used when DCH is reconfigured */
   DCH_ASU,                                        /* Used when active set update */
   DCH_LOOP_MODE_2                                 /* Used when DCH loop back mode 2 */
} dch_modify_msg_type_E;


typedef enum _msg_container_error_E              /* Error cause of message container, MA only*/
{
   NONE,
   DCH_SETUP_FAIL
} msg_container_error_E;

typedef enum _TGPS_Action_E
{
   TGPS_ACT_START,
   TGPS_ACT_STOP,
   TGPS_ACT_SUSPEND,
   TGPS_ACT_RESUME,
   TGPS_ACT_CONTINUE,
   TGPS_ACT_DELETE  
} TGPS_Action_E;

typedef struct _TGPS_Action_T
{
   kal_uint8      tgpsi;                           /* TGPIS of the TGPS on which the action and apply flag should be applied */
   kal_bool       apply_current;                  
   kal_bool       apply_suspend;
   TGPS_Action_E  action;
} TGPS_Action_T;

typedef enum _meas_control_E
{
   MEAS_CTRL_INVALID,                       /* No meas. control action in current MSG_CONTAINER */
   MEAS_STOP,                                      /* UL1 do not need to resume measurement after apply current MSG_CONTAINER */
   MEAS_CONTI,                                     /* UL1 do need to resume measurement after apply current MSG_CONTAINER */
                                                   /* The measurement settings should be same as latest MSG_ID_CPHY_MEASUREMENT_CONFIG_CELL_REQ */
   MEAS_SFN_STOP,                               /* UL1 do need to resume measurement but not include SFN tracking 
                                                                 after apply current MSG_CONTAINER. Currently, it is used in Blind inter-freq HHO case */
   MEAS_CM_STOP,                                 /* For inter-RAT HHO, stop CM measurement when receiving DCH release msg */                                                              
   MAX_MEAS_CONTROL = MEAS_CM_STOP
} meas_control_E;

/*Add for improving full band FS efficiency -- by excluding some UARFCN or some frequency range*/
typedef enum _full_band_option_E
{
  FULL_BAND_ONLY,                        /*Normal full band FS*/
  FULL_BAND_AND_EXCLUDE          /*Full band FS but the indicated frequency list/range will be excluded in the full band FS procedure*/
} full_band_option_E;
#if defined( __GEMINI_GSM__ ) && defined ( __UMTS_RAT__ )            
typedef enum _uas_gemini_conflict_cause_enum
{ 
    URR_NO_CONFLICT, 
    URR_CONFLICT_WITH_WCDMA_BCH_HIGH, 
    URR_CONFLICT_WITH_WCDMA_PICH, 
    URR_CONFLICT_WITH_WCDMA_CTCH, 
    URR_CONFLICT_WITH_WCDMA_BCH_LOW, 
    URR_CONFLICT_WITH_GSM_NBCCH, 
    URR_CONFLICT_WITH_GSM_PCH, 
    URR_CONFLICT_WITH_GSM_BCCH, 
    URR_CONFLICT_WITH_GSM_OTHERS
} uas_gemini_conflict_cause_enum; 

typedef enum _rrce_gemini_priority_adjust_E
{ 
    GEMINI_PRIORITY_ADJUST_ALL,          /* Currently only used in Gemini2.0, to raise all rx/tx/BCH channel priority for RRC connection establishment or DL sync procedure. */
    GEMINI_PRIORITY_ADJUST_CTCH        /* R8 ETWS feature, used for receiving ETWS CB. */
} rrce_gemini_priority_adjust_E;
#endif 
/*-------- [R5R6] HS-DSCH related ----------------------*/
typedef enum _hs_cqi_k_E
{
   CQI_K_0, 
   CQI_K_2, 
   CQI_K_4, 
   CQI_K_8, 
   CQI_K_10, 
   CQI_K_20, 
   CQI_K_40, 
   CQI_K_80, 
   CQI_K_160,
   /* __UMTS_R7__ BEGIN */
   CQI_K_16,
   CQI_K_32,
   CQI_K_64
   /* __UMTS_R7__ END */
} hs_cqi_k_E;

#ifdef __UMTS_R7__
/* [R7] UE_OWN_CATEGORY or CATEGORY_12. According to 25.331 CR#4159, UE should use the number of soft channel bits 
   according to this category to decode HS-PDSCH TB. */
typedef enum _hs_harq_ir_type_E
{
   UE_OWN_CATEGORY = 0,
   CATEGORY_12		
} hs_harq_ir_type_E;

typedef struct _hs_tb_size_list_T 
{
   kal_int8      tbs_index;              /* [Range] 1~90, -1 if this is invalid */
   kal_bool      second_code_support;    /* Indicates whether the second HS-PDSCH code is used for this TB size.
                                            If TRUE, the HS-PDSCH second code index value is the value of IE 'HSPDSCH Code Index' incremented by 1. */ 	
} hs_tb_size_list_T;

/* [R7] MAC entity types for handling HS-DSCH */
typedef enum _hs_mac_entity_type_E
{
   HS_MAC_HS_ENTITY = 0,
   HS_MAC_EHS_ENTITY,
   HS_MAC_EHS_ENTITY_DC
}hs_mac_entity_type_E;
#endif  /* __UMTS_R7__ */

typedef struct _hs_scch_info_T
{
   kal_uint8      ssc;                     /* DL scrambling code to be applied for HS-DSCH and HS-SCCH */
   kal_uint8		ovsf_code_num;	         /* Number of HS-SCCH to be received. Range:1~4 */
   kal_uint8     ovsf[MAX_HS_SCCH_NUM];  /* OVSF code of HS-SCCH to be received */
} hs_scch_info_T;

typedef struct _hs_meas_fb_info_T
{
   kal_int8		   meas_po;		/* Measurement power offset. Range: -12~26 */
   hs_cqi_k_E		cqi_k;		/* Measurement feedback cycle */
   kal_uint8		cqi_repe_factor;	/* CQI repetition factor. Range: 1~4 */
   kal_uint8		delta_cqi;		/* DeltaCQI. Range: 0~8 */
} hs_meas_fb_info_T;

typedef struct _hs_harq_info_T 
{
   kal_uint8		process_num;		         /* Number of HARQ process. Range: 1~8 */
   kal_bool		   explicit_partition;		   /* TRUE indicates explicit memory partition. FALSE indicates implicit memory partition */
   kal_uint8		process_mem_size[MAX_HS_PROCESS_NUM];	/* index of HARQ memory size. range: 0~60, only valid when memory partition is explicit */
#ifdef __UMTS_R7__
   hs_harq_ir_type_E      harq_ir_type;      /* UE_OWN_CATEGORY or CATEGORY_12. According to 25.331 CR#4159, UE should use the number of soft channel bits 
                                                according to this category to decode HS-PDSCH TB. */
   hs_mac_entity_type_E   hs_mac_entity;     /* enum for MAC-hs, MAC-ehs and MAC-ehs with DC */
#endif /* __UMTS_R7__ */
} hs_harq_info_T;

typedef struct _hs_ulpc_info_T 
{
   kal_uint8		delta_ack;		/* delta_ack. range: 0~8 */
   kal_uint8		delta_nack;		/* delta_nack. range: 0~8 */
   kal_uint8		acknack_repe_factor;	/* ack_nack_repetition_factor. range: 1~4 */
   kal_uint8		harq_preamble_mode; /* [R6] range: 0~1, 1: indicates the preamble and postable are used
                                                                        for R5 and previous version, this value should be 0 */
} hs_ulpc_info_T;

#ifdef __UMTS_R8__ 

typedef enum 
{
   DSCH_NO_HRNTI_DETECTED = 0, /*HS-SCCH CRC check is failed*/
   DSCH_D_HRNTI_DETECTED  = 1, /*HS-PDSCH is indicated by HS-SCCH with dH-RNTI*/
   DSCH_C_HRNTI_DETECTED  = 2, /*HS-PDSCH is indicated by HS-SCCH with cH-RNTI*/
   DSCH_B_HRNTI_DETECTED  = 3, /*HS-PDSCH is indicated by HS-SCCH with bH-RNTI*/
   DSCH_HRNTI_LESS        = 4, /*HS-PDSCH is decoded blindly without HS-SCCH  */
   DSCH_NOT_RECEIVE       = 5, /*This subframe is not received by HW */

} hs_dsch_decode_hrnti_E;

#endif /*__UMTS_R8__*/

typedef struct _hsdsch_data_T
{
   kal_bool               Is_valid_data;    /* MAC-hs PDU is existent or not */
   kal_uint16             tb_size;          /*[Range]: 137 ~ 27952 bits, MAC-hs PDU size */
   kal_uint8              *data;            /* The buffer contains MAC-hs data */

#ifdef __UMTS_R8__ 
   hs_dsch_decode_hrnti_E decode_hrnti;     /*H-RNTI dectected info*/
#endif /* __UMTS_R8__ */
#ifdef  __SMART_PAGING_3G_FDD__
   kal_int8                   pi_repeat_cycle;/* -1:invalid, -2:retransmission with CRC pass, 1~20:valid pi_repeat_cyle */
#endif /* __SMART_PAGING_3G_FDD__ */  
} hsdsch_data_T;

#ifdef __UMTS_R7__
typedef enum _mac_ehs_reset_cause_E
{
    Treset_Expired
} mac_ehs_reset_cause_E;
#endif /* __UMTS_R7__ */

typedef enum _edch_tti_E
{
   EDCH_TTI_2 = 0, 
   EDCH_TTI_10 = 1
} edch_tti_E;

typedef enum _edch_sf_E
{
   EDCH_SF256 = 0, 
   EDCH_SF128 = 1, 
   EDCH_SF64 = 2,    
   EDCH_SF32 = 3, 
   EDCH_SF16 = 4, 
   EDCH_SF8 = 5,    
   EDCH_SF4 = 6, 
   EDCH_ONE_PHCH = 6,   
   EDCH_2SF4 = 7, 
   EDCH_SF2 = 7,    
   EDCH_2SF2 = 8,    
   EDCH_2SF2AND2SF4 = 9,
#ifdef __UMTS_R7__
   EDCH_2SF2AND2SF4_16QAM = 10,
   EDCH_SF_CNT = 11,
   EDCH_SF_NA = 12   
#else
   EDCH_SF_CNT = 10,
   EDCH_SF_NA = 11   
#endif   
} edch_sf_E;


typedef enum _edch_rv_config_E
{
   EDCH_RV0 = 0,
   EDCH_RVTABLE = 1
} edch_rv_config_E;

typedef struct _eagch_info_T
{
   kal_uint16        psc;                   /* Primary scrambling code. 1 ~ 511 */
   kal_uint8        ovsf;                   /* OVSF code. 0 ~ 255 */   
   kal_uint16        dpch_offset;           /* DPCH frame offset to P-CPICH of this cell */   
   tx_diversity_E    tx_diversity_mode;     /* TX diversity mode of E-AGCH, and the value only can be DL_TX_NONE or DL_TX_STTD.*/
} eagch_info_T;

typedef struct _ehich_info_T
{
   kal_uint16        psc;                    /* Primary scrambling code. 1 ~ 511 */
   kal_uint8         ovsf;                   /* OVSF code. 0 ~ 127 */      
   kal_uint16        dpch_offset;            /* DPCH frame offset to P-CPICH of this cell (tauDPCH) */           
   tx_diversity_E    tx_diversity_mode;      /* TX diversity mode of E-HICH, and the value only can be DL_TX_NONE or DL_TX_STTD.*/
   kal_uint8         signature_seq;          /* E-HICH signature sequence 0~39*/
   kal_uint8         tpc_index;              /* TPC combination index. 0 ~ 5 */
} ehich_info_T;

typedef struct _ergch_info_T
{
   kal_uint16        psc;                    /* Primary scrambling code. 1 ~ 511 */
   kal_uint8        ovsf;                    /* OVSF code. 0 ~ 127. Should be the same as E-HICH ovsf code */      
   kal_uint16        dpch_offset;            /* DPCH frame offset to P-CPICH of this cell (tauDPCH) */   
   tx_diversity_E    tx_diversity_mode;      /* TX diversity mode of E-RGCH, and the value only can be DL_TX_NONE or DL_TX_STTD.*/
   kal_uint8         signature_seq;          /* E-RGCH signature sequence 0~39*/
   kal_uint8         rg_comb_index;          /* RG combination index. 0 ~ 5 */   
} ergch_info_T;

typedef struct _ref_etfci_T
{
   kal_uint8         ref_etfci;                 /* Reference E-TFCI. 0~127 */
/* __UMTS_R7__ */
   kal_uint8         ref_etfci_po;              /* Reference E-TFCI PO. 0~31 */
} ref_etfci_T;

#ifdef __UMTS_R8__
/* [R8] Minimum reduced E-DPDCH gain factor */
typedef enum _beta_ed_reduced_min_E
{
   beta_ed_8_15 = 0,                        /* 8/15 */
   beta_ed_11_15,                           /* 11/15 */
   beta_ed_15_15,                           /* 15/15 */
   beta_ed_21_15,                           /* 21/15 */
   beta_ed_30_15,                           /* 30/15 */
   beta_ed_42_15,                           /* 42/15 */
   beta_ed_60_15,                           /* 60/15 */
   beta_ed_84_15                            /* 84/15 */
}beta_ed_reduced_min_E;
#endif /* __UMTS_R8__ */

typedef struct _edpdch_info_T
{
/* __UMTS_R7__ */
   kal_uint8      etfci_table_index;                      /* E-TFCI table index. 0~1. If the UE is operating in 16QAM, the value is increased by 2. 0~3.  */
   kal_uint8      num_of_ref_etfci;                      /* number of reference etfci. range:1~8 */
   ref_etfci_T    ref_etfci[MAX_REF_ETFCI_NUM];    /* reference E-TFCIs */
   edch_sf_E      max_ch_code;            /* Max. channelisation code */
   kal_uint8      ul_dpch_num;                              /* # of UL DPCH, range:0~MAX_ULDPCH*/
   kal_uint8      pl_non_max;                               /* PLnon-max*100/4, range:11~25 */
#ifdef __UMTS_R8__
   beta_ed_reduced_min_E   beta_ed_reduced_min;             /* Minimum reduced E-DPDCH gain factor */
#endif /* __UMTS_R8__ */
} edpdch_info_T;

typedef struct _edpcch_info_T
{
   kal_uint8        edpcch_po;                    /* E-DPCCH/DPCCH power offset. 0~8  */
#ifdef __UMTS_R7__
   kal_uint8      etfci_boost;            /* [Range] Integer(0..127)E-TFCI threshold beyond which boosting of EDPCCH is enabled */
   kal_uint8      delta_t2tp;            /* [Range] Integer (0..6)If E-TFCI-Boost is set to 127 this IE is not needed, otherwise it is mandatory. */
   kal_bool      edpdch_pwr_interpolation;            /* True means EDPDCH power Interpolation formula is used, False means EDPDCH power 
                                                                                 Extrapolation formula is used for the computation of the gain factor ]ed */
#endif /* __UMTS_R7__ */
} edpcch_info_T;

typedef struct _edch_harq_info_T
{
   edch_rv_config_E  edch_rv_config;           /* RV config */
} edch_harq_info_T;


/**********************************************************************************************************************/
/***********************************   UL1 Interface maintained by UL1D (Begin)   *************************************/
/**********************************************************************************************************************/
/*UL1D*/typedef enum _hs_dsch_dc_data_source_E
/*UL1D*/{	
/*UL1D*/	PRIMARY_CELL   = 0, 	/* data from primary cell, only hsdsch_data[] should be processed */
/*UL1D*/	SECONDARY_CELL = 1,     /* data from secondary cell, only hsdsch_data2[] should be processed */
/*UL1D*/	DUAL_CELL      = 2      /* data from dual cells, both hsdsch_data[] and hsdsch_data2[] should be processed*/
/*UL1D*/} hs_dsch_dc_data_source_E;
/*UL1D*/
/*UL1D*/typedef struct _uldch_data_req_T 
/*UL1D*/{ 
/*UL1D*/   kal_uint8         cfn;
/*UL1D*/   kal_uint8         ul_mac_event;         /* bit 0: UL DCH setup,   */ 
/*UL1D*/  	                                       /* bit 1: UL DCH release, */
/*UL1D*/  	                                       /* bit 2: UL DCH modify   */
/*UL1D*/   kal_uint8         dpdch_num;
/*UL1D*/   kal_bool          restartSRB;
/*UL1D*/   kal_bool          tx_enable;
/*UL1D*/   kal_bool          tx_suspend;
/*UL1D*/   kal_uint8         tfc_status[MAX_UL_TFC];
/*UL1D*/} uldch_data_req_T;
/*UL1D*/
/*UL1D*/
/*UL1D*/typedef struct _uldch_data_ind_T 
/*UL1D*/{ 
/*UL1D*/   kal_uint8         cfn;
/*UL1D*/   kal_uint8         num_trch;   
/*UL1D*/   ulTrchData        trchInfo[MAX_TRCH_NUM]; /* TrCH information including number of TB and TB size. Note that only 1 TRCH is included in RACH data. */   
/*UL1D*/   kal_uint16        tfci;
/*UL1D*/   kal_uint16        num_data[MAX_TRCH_NUM]; /* num_data[MAX_TRCH_NUM]. It means the total TB size on 1 TRCH. Value: 0 ~ MAX_UL_TB. */
/*UL1D*/   kal_uint8         *data[MAX_TRCH_NUM];
/*UL1D*/
/*UL1D*/   tPhyPostTxElement PostTxElement;   /* Transparent in UL1D */   
/*UL1D*/#ifdef  UNIT_TEST
/*UL1D*/   void    *addr;
/*UL1D*/#endif /* UNIT_TEST */
/*UL1D*/} uldch_data_ind_T;
/*UL1D*/
/*UL1D*//* Input parameters of umac_e_dch_tick_1() */
/*UL1D*/typedef struct _etfc_eval_info_req_T   
/*UL1D*/{
/*UL1D*/   kal_uint8    cfn;              /* Range: 0..255 */
/*UL1D*/   kal_uint8    subframe;         /* 10ms=0, 2ms=0..4. */
/*UL1D*/
/*UL1D*/   kal_uint8    mac_event;        /* bit 0: MAC-e/es setup,   */ 
/*UL1D*/  	                              /* bit 1: MAC-e/es release, */
/*UL1D*/  	                              /* bit 2: MAC-e/es modify   */
/*UL1D*/   
/*UL1D*/   edch_tti_E   edch_tti;         /* E-DCH TTI 2ms or 10ms */  
/*UL1D*/
/*UL1D*/   kal_bool     is_tx_suspend;    /* If Tx suspended*/
/*UL1D*/#if defined(__GEMINI_MONITOR_PAGE_DURING_TRANSFER__) && defined(__GEMINI_GSM__) && defined(__UMTS_RAT__)
/*UL1D*/   kal_bool     is_gemini_tx_suspend;    /* If Tx suspended due to Gemini */
/*UL1D*/#endif
/*UL1D*/   
/*UL1D*/   kal_bool     compressed_2ms;  /* If the corresponding subframe overlaps TG (Refer this value only when 2ms TTI) */
/*UL1D*/   kal_uint8    num_of_non_dtx_slots_10ms;  /* number of  non-gap slots in the corresponding TTI (Refer this value only when 10ms TTI) */
/*UL1D*/
/*UL1D*/   kal_uint8    e_agch_result;  //0: Invalid 1:primary E-RNTI detected 2: secondary E-RNTI detected
/*UL1D*/   kal_uint8    e_agch_data;  //bit:   
/*UL1D*/   kal_uint8    e_hich_result_serving;  /*0:DTX, 1:ACK, 2:invalid(shall ASSERT), 3:NACK */
/*UL1D*/   kal_uint8    e_hich_result_non_serving;  /*0:DTX or NACK, 1:ACK, 2:invalid(shall ASSERT) , 3:invalid(shall ASSERT)*/
/*UL1D*/   kal_uint8    e_rgch_result_serving;  /*0:HOLD or DTX, 1:UP, 2:invalid(shall ASSERT), 3:DOWN */
/*UL1D*/   kal_uint8    e_rgch_result_non_serving;  /*0:HOLD or DTX, 1:invalid(shall ASSERT), 2:invalid(shall ASSERT), 3:DOWN */
/*UL1D*/
/*UL1D*/   kal_bool     isTtiChangeSuspend;
/*UL1D*/   kal_bool     isServingCellChange;
/*UL1D*/   kal_bool     isServingCellChNotPartOfPrevEdchRls;
/*UL1D*/   kal_uint16   mac_harq_event;  /* bit 0: TTI change */
/*UL1D*/                                 /* bit 1: E-TFCI table index change */
/*UL1D*/                                 /* bit 2: HARQ RV ReConfiguration */
/*UL1D*/                                 /* bit 3: PLnon-max change */
/*UL1D*/#ifdef __UMTS_R7__
/*UL1D*/   kal_bool   insufficient_preamble;	// Cannot transmit E-DCH due to insufficient UL DPCCH preamble.
/*UL1D*/   kal_bool   match_mac_dtx_cycle;	// If the condition of last paragraph of 25.321 11.8.1.4 is fulfilled.
/*UL1D*/   kal_bool   is_dtx_cycle_2;	// The DTX feature is configured by higher layers, and there has not been any E-DCH transmission for the last "Inactivity Threshold for UE DTX cycle 2" E-DCH TTIs.
/*UL1D*/#endif // __UMTS_R7__
/*UL1D*/
/*UL1D*/#ifdef __UMTS_R8__
/*UL1D*/    kal_bool    is_cedch;        /*Notify UMAC if common EDCH or not*/
/*UL1D*/#endif
/*UL1D*/   kal_uint8*   sf_of_etfci;
/*UL1D*/   kal_bool     restartSRB;
/*UL1D*/   kal_uint8*   L2_Budget;     // in unit of slot
/*UL1D*/
/*UL1D*/} etfc_eval_info_req_T ;
/*UL1D*/
/*UL1D*//* Output parameters of umac_e_dch_tick_1() */
/*UL1D*/typedef struct _etfc_eval_info_ind_T
/*UL1D*/{
/*UL1D*/   kal_uint8  cfn;              /* Range: 0..255 */
/*UL1D*/   kal_uint8  subframe;         /* 10ms=0, 2ms=0..4. */
/*UL1D*/   
/*UL1D*/   kal_uint8  harq_id;          /* 2ms TTI: 0..7, 10ms TTI: 0..3 */
/*UL1D*/   
/*UL1D*/   kal_bool   tx_enable;        /* true=on, false=off */
/*UL1D*/   kal_bool   is_new_tx;
/*UL1D*/   
/*UL1D*/   kal_uint8  delta_harq;
/*UL1D*/   
/*UL1D*/#ifdef __UMTS_R7__
/*UL1D*/   kal_bool   tebs_larger_than_0;	// At least one MAC-d flow is configured with a scheduled transmission and TEBS > 0
/*UL1D*/#endif // __UMTS_R7__   
/*UL1D*/
/*UL1D*/#ifdef __UMTS_R8__
/*UL1D*/   kal_bool   collision_resolved;
/*UL1D*/#endif // __UMTS_R8_   
/*UL1D*/} etfc_eval_info_ind_T;
/*UL1D*/
/*UL1D*//* Input parameters of umac_e_dch_tick_2() */
/*UL1D*/typedef struct _edch_data_req_T 
/*UL1D*/{
/*UL1D*/   kal_uint8    cfn;              /* Range: 0..255 */
/*UL1D*/   kal_uint8    subframe;         /* 10ms=0, 2ms=0..4. */
/*UL1D*/   
/*UL1D*/   edch_tti_E  edch_tti;                     /* E-DCH TTI 2ms or 10ms */  
/*UL1D*/
/*UL1D*/   kal_bool     compressed_2ms;  /* If the corresponding subframe overlaps TG (Refer this value only when 2ms TTI) */
/*UL1D*/   kal_uint8    num_of_non_dtx_slots_10ms;  /* number of  non-gap slots in the corresponding TTI (Refer this value only when 10ms TTI) */
/*UL1D*/
/*UL1D*/   
/*UL1D*/   kal_uint8    e_agch_result;  //0: Invalid 1:primary E-RNTI detected 2: secondary E-RNTI detected
/*UL1D*/   kal_uint8    e_agch_data;  //Bit 0 - Scope. Bit 1 ~ Bit5 - AG Value
/*UL1D*/   kal_uint8    e_hich_result_serving;  /*0:DTX or NACK, 1:ACK, 2:invalid(shall ASSERT), 3:invalid(shall ASSERT) */
/*UL1D*/   kal_uint8    e_hich_result_non_serving;  /*0:DTX or NACK, 1:ACK, 2:invalid(shall ASSERT) , 3:invalid(shall ASSERT)*/
/*UL1D*/   kal_uint8    e_rgch_result_serving;  /*0:HOLD or DTX, 1:UP, 2:invalid(shall ASSERT), 3:DOWN */
/*UL1D*/   kal_uint8    e_rgch_result_non_serving;  /*0:HOLD or DTX, 1:invalid(shall ASSERT), 2:invalid(shall ASSERT), 3:DOWN */
/*UL1D*/
/*UL1D*/   kal_uint8*   supported_etfci_bitmap;   /* 2 LSB bits of [0] = etfci 0, 2 MSB bits of [31] = etfci 127. */
/*UL1D*/                                           /* 11=support, 10=power not support, 01=data size not support, 00=not support */
/*UL1D*/   kal_uint16   uph_in_dB;   /*UE transmission power headroom reported by UL1(unit: dB)*/
/*UL1D*/   kal_uint8*   sf_of_etfci;  /* sf_of_etfci[64] stands for 128 SF of E-TFCI, sf_of_etfci[0]&0xF -> ETFCI=0, sf_of_etfci[0]>>4 -> ETFCI=1 */
/*UL1D*/                              // EDCH_SF256 = 0, 
/*UL1D*/                              // EDCH_SF128 = 1, 
/*UL1D*/                              // EDCH_SF64 = 2,    
/*UL1D*/                              // EDCH_SF32 = 3, 
/*UL1D*/                              // EDCH_SF16 = 4, 
/*UL1D*/                              // EDCH_SF8 = 5,    
/*UL1D*/                              // EDCH_SF4 = 6, 
/*UL1D*/                              // EDCH_ONE_PHCH = 6,   
/*UL1D*/                              // EDCH_2SF4 = 7, 
/*UL1D*/                              // EDCH_SF2 = 7,    
/*UL1D*/                              // EDCH_2SF2 = 8,    
/*UL1D*/                              // EDCH_2SF2AND2SF4 = 9,
/*UL1D*/                              // EDCH_SF_CNT = 10,
/*UL1D*/                              // EDCH_SF_NA = 11 
/*UL1D*/} edch_data_req_T ;
/*UL1D*/
/*UL1D*/
/*UL1D*//* Output parameters of umac_e_dch_tick_2() */
/*UL1D*/typedef struct _edch_data_ind_T 
/*UL1D*/{
/*UL1D*/   kal_uint8  cfn;              /* Range: 0..255 */
/*UL1D*/   kal_uint8  subframe;         /* 10ms=0, 2ms=0..4. */
/*UL1D*/   kal_bool   tx_enable;        /* true=on, false=off */
/*UL1D*/   kal_uint8  harq_id;          /* 2ms TTI: 0..7, 10ms TTI: 0..3 */
/*UL1D*/   kal_bool   is_new_tx;
/*UL1D*/   kal_uint8  etfci;            /* Range: 0..127 */
/*UL1D*/   kal_uint8  ntx1;             /* 10 ms TTI: 8..15, 2ms TTI: don't care */
/*UL1D*/   kal_bool   happy;
/*UL1D*/   kal_uint8  rsn;              /* Range: 0..3 */
/*UL1D*/   kal_uint8  delta_harq;       /* Range: 0..6 */
/*UL1D*/   kal_uint16 tb_size;
/*UL1D*/   kal_uint8* data;             /* The buffer contains MAC-es/e PDU data */
/*UL1D*/                                /* Must be 4 bytes alignment */
/*UL1D*/                                /* NULL if tx_enable == false */
/*UL1D*/   kal_uint8  tebs;             /* SI of UMAC */
/*UL1D*/   kal_uint8  re_tx_num;        /* re-transmission number */
/*UL1D*/   kal_uint32 ScheduledGrantPayloadBits;      /* Configured SG bits; for RG judgement */
/*UL1D*/   kal_uint32 ScheduledGrantUsedBits;          /* Used SG bits; for RG judgement */
#ifdef __UMTS_R7__
   kal_bool   scheduled;	// Whether this is scheduled E-DCH transmission or not.
#endif // __UMTS_R7__                                
/*UL1D*/} edch_data_ind_T;
/*UL1D*/
/*UL1D*//* No output parameters of umac_e_dch_tick_3() */
/*UL1D*/
/*UL1D*//* Input parameters of umac_e_dch_tick_3() */
/*UL1D*/typedef struct _umac_edch_data_req_tick_3_T 
/*UL1D*/{
/*UL1D*/   kal_uint8  cfn;              /* Range: 0..255 */
/*UL1D*/   kal_uint8  subframe;         /* 10ms=0, 2ms=0..4. */
/*UL1D*/} umac_edch_data_req_tick_3_T;
/*UL1D*/
/*UL1D*//* Output parameters of umac_e_dch_tick_3() */
/*UL1D*/typedef struct _umac_edch_data_ind_tick_3_T 
/*UL1D*/{
/*UL1D*/   kal_uint8  cfn;              /* Range: 0..255 */
/*UL1D*/   kal_uint8  subframe;         /* 10ms=0, 2ms=0..4. */
/*UL1D*/} umac_edch_data_ind_tick_3_T;
/*UL1D*/
/*UL1D*/extern void UL1D_L2PutHISRQueue(void (*code)(void*), void* data);
/*UL1D*/kal_bool UL1D_Check_ASU(kal_int32  added_cell_tm/* echips */, kal_uint16  added_cell_dpch_offset /* chips */);
/*UL1D*/kal_bool UL1D_RxDualCarrier_Check(kal_uint16 pri_uarfcn, kal_uint16 sec_uarfcn, kal_int16 *pri_sec_diff);
/**********************************************************************************************************************/
/***********************************   UL1 Interface maintained by UL1D (End)   ***************************************/
/**********************************************************************************************************************/
#ifdef __UMTS_R7__

/* Input parameters of umac_e_dch_tick_5() */
typedef struct
{
   kal_bool     match_mac_dtx_cycle;
   kal_uint8    long_preamble_target_cfn;          // 0..255.
   kal_uint8    long_preamble_target_subframe;     // 10ms=0, 2ms=0..4.
} etfc_eval_lpr_info_req_T;

#endif // __UMTS_R7__

#ifdef __UMTS_R7__
/* [R7] Enumeration of rrc state. To distinguish the usage of HS-DSCH */
typedef enum _rrc_state_E
{
   CELL_DCH = 0,
   URA_PCH,
   CELL_PCH,
   IDLE_FACH,
   CELL_FACH
} rrc_state_E;

/* [R7] Enumeration of octet aligned table 9.2.3.2 is used, else bit aligned table 9.2.3.1 is used in [25.321]. */
typedef enum _hs_tbsize_table_E
{
   BIT_ALIGNED = 0,
   OCTET_ALIGNED		
} hs_tbsize_table_E;

/* [R7] Enumeration of dtx_drx_status. */
typedef enum _dtx_drx_status_E
{
   DTX_DRX_OFF = 0,            /* Disable CPC operation */
   DTX_DRX_NEW_TIMING,            /* Use new CPC configuration */
   DTX_DRX_ON_REVERT,            /* Uses the old CPC configuration when HHO revert. Consider oly the HS-SCCH orders which were acknowledged prior to the activation timer of the received message. */
   DTX_DRX_ON_HS_SERV_CELL_CHANGE,            /* Uses the old CPC configuration when serving cell was changed. Consider the HS-SCCH order were never received. */
   DTX_DRX_ALL_RL_TIMING_MODIFY,            /* If the CPC choice timing is continue when receiving ALL RL TIMING MODIFY, Uses the old CPC configuration. */
   DTX_DRX_INVALID            /* Invalid DTX_DRX status */
} dtx_drx_status_E;

/* [R7] Enumeration of enabling delay. Uint is radio frame. */
typedef enum _enabling_delay_E
{
   ED_0 = 0,
   ED_1,
   ED_2,
   ED_4,
   ED_8,
   ED_16,
   ED_32,
   ED_64,
   ED_128
} enabling_delay_E;

/* [R7] Enumeration of ue_dtx_cycle2_inactivity_threshold. Uint is E-DCH TTIs. */
typedef enum _ue_dtx_cycle2_inactivity_threshold_E
{
   dtx_cycle2_inaTrHd_1 = 0,
   dtx_cycle2_inaTrHd_4,
   dtx_cycle2_inaTrHd_8,
   dtx_cycle2_inaTrHd_16,
   dtx_cycle2_inaTrHd_32,
   dtx_cycle2_inaTrHd_64,
   dtx_cycle2_inaTrHd_128,
   dtx_cycle2_inaTrHd_256
} ue_dtx_cycle2_inactivity_threshold_E;

/* [R7] Enumeration of ue_dtx_long_preamble_length. Uint is slot. */
typedef enum _ue_dtx_long_preamble_length_E
{
   slot_2 = 0,
   slot_4,
   slot_15
} ue_dtx_long_preamble_length_E;

/* [R7] Enumeration of cqi_dtx_timer period. Uint is subframe. */
typedef enum _cqi_dtx_timer_E
{
   subframe_0 = 0,
   subframe_1,
   subframe_2,
   subframe_4,
   subframe_8,
   subframe_16,
   subframe_32,
   subframe_64,
   subframe_128,
   subframe_256,
   subframe_512,
   subframe_infinity
} cqi_dtx_timer_E;

/* [R7] Enumeration of ue_dpcch_burst. Uint is subframe. */
typedef enum _ue_dpcch_burst_E
{
   burst_1 = 0,
   burst_2,
   burst_5
} ue_dpcch_burst_E;

/* [R7] Enumeration of mac_inactivity_threshold. Uint is E-DCH TTI. */
typedef enum _mac_inactivity_threshold_E
{
   mac_inaTrHd_1 = 0,
   mac_inaTrHd_2,
   mac_inaTrHd_4,
   mac_inaTrHd_8,
   mac_inaTrHd_16,
   mac_inaTrHd_32,
   mac_inaTrHd_64,
   mac_inaTrHd_128,
   mac_inaTrHd_256,
   mac_inaTrHd_512,
   mac_inaTrHd_infinity
} mac_inactivity_threshold_E;

/* [R7] Enumeration of ue_rx_cycle. Uint is subframe. */
typedef enum _ue_drx_cycle_E
{
   drx_cycle_4 = 0,
   drx_cycle_5,
   drx_cycle_8,
   drx_cycle_10,
   drx_cycle_16,
   drx_cycle_20
} ue_drx_cycle_E;

/* [R7] Enumeration of ue_drx_cycle_inactivity_threshold. Uint is subframe. */
typedef enum _ue_drx_cycle_inactivity_threshold_E
{
   drx_cycle_inaTrHd_0 = 0,
   drx_cycle_inaTrHd_1,
   drx_cycle_inaTrHd_2,
   drx_cycle_inaTrHd_4,
   drx_cycle_inaTrHd_8,
   drx_cycle_inaTrHd_16,
   drx_cycle_inaTrHd_32,
   drx_cycle_inaTrHd_64,
   drx_cycle_inaTrHd_128,
   drx_cycle_inaTrHd_256,
   drx_cycle_inaTrHd_512
} ue_drx_cycle_inactivity_threshold_E;

/* [R7] Enumeration of ue_grantMonitoring_inactivity_threshold. Uint is subframe. */
typedef enum _ue_grantMonitoring_inactivity_threshold_E
{
   graMon_inaTrhd_0 = 0,
   graMon_inaTrhd_1,		
   graMon_inaTrhd_2,
   graMon_inaTrhd_4,
   graMon_inaTrhd_8,
   graMon_inaTrhd_16,
   graMon_inaTrhd_32,
   graMon_inaTrhd_64,
   graMon_inaTrhd_128,
   graMon_inaTrhd_256
} ue_grantMonitoring_inactivity_threshold_E;

/* [R7] HS-SCCH less mode status in CELL_DCH state */
typedef enum _hs_scch_less_status_E
{
   HS_SCCH_LESS_OFF = 0,                    /* disable HS-SCCH less operation and all HS-SCCH less parameters are invalid. */
   HS_SCCH_LESS_ON,                         /* use new HS-SCCH less configuration and reset order. */
   HS_SCCH_LESS_ON_REVERT,                  /* Uses the old HS-SCCH less configuration when HHO revert or 3G to 2G inter-RAT procedure revert. */
   HS_SCCH_LESS_ALL_RL_TIMING_MODIFY,       /* If the HS-SCCH less operation choice timing is "continue" when receiving ALL RL TIMING MODIFY, 
                                             * uses the old HS-SCCH less configuration without reset order. */
   HS_SCCH_LESS_INVALID                     /* SLCE internal use, won't config this enum to UL1. */
}hs_scch_less_status_E;
#endif /* __UMTS_R7__ */

#ifdef __UMTS_R8__
/* [R8] Enumeration of enhanced CELL_FACH DRX status */
typedef enum _hs_cell_fach_drx_status_E
{
   DRX_OFF = 0,                             /* No DRX in CELL_FACH state or ETWS reception is on-going */
   DRX_ON_NORMAL,                           /* UL1 should start CELL_FACH DRX when the normal criterion is fulfilled */
   DRX_ON_ETWS_END,                         /* SLCE should set this enum when the ETWS procedure ends */
   DRX_INVALID                              /* SLCE internal use. Invalid for UL1. */
}hs_cell_fach_drx_status_E;

/* [R8] inactivity timer to start HS CELL_FACH DRX */
typedef enum _hs_t321_E
{
   t321_100 = 0,                            /* 100ms */
   t321_200 = 1,                            /* 200ms */
   t321_400 = 2,                            /* 400ms */
   t321_800 = 3                             /* 800ms */
}hs_t321_E;

/* [R8] HS CELL_FACH DRX cycle length */
typedef enum _hs_drx_cycle_E
{
   hs_drx_cycle_4  = 0,                      /* 4 frames */
   hs_drx_cycle_8  = 1,                      /* 8 frames */
   hs_drx_cycle_16 = 2,                      /* 16 frames */
   hs_drx_cycle_32 = 3                       /* 32 frames */
}hs_drx_cycle_E;

/* [R8] determine the period within the HS DRX cycle that the UE continuously receive HS-DSCH, in frames */
typedef enum _hs_drx_burst_E
{
   hs_drx_burst_1  = 0,                      /* 1 frames */
   hs_drx_burst_2  = 1,                      /* 2 frames */
   hs_drx_burst_4  = 2,                      /* 4 frames */
   hs_drx_burst_8  = 3,                      /* 8 frames */
   hs_drx_burst_16 = 4                       /* 16 frames */
}hs_drx_burst_E;

/* [R8] variable to control UL1 DC HS-DSCH receiving */
typedef enum _dc_hsdpa_status_E
{
   DC_HSDPA_OFF = 0,                        /* Disable DC-HSDPA operation and all DC-HSDPA parameters are invalid. */
   DC_HSDPA_ON,                             /* Use new DC-HSDPA configuration and reset order */
   DC_HSDPA_ON_REVERT,                      /* Uses the old DC-HSDPA configuration when HHO revert or 3G to 2G inter-RAT procedure revert. */
   DC_HSDPA_ALL_RL_TIMING_MODIFY,           /* If the DC-HSDPA choice timing is "continue" when receiving ALL_RL_TIMING_MODIFY, 
                                             * uses the old DC-HSDPA configuration without reset order. */
   DC_HSDPA_ON_WITHOUT_RESET_ORDER,         /* Use new DC-HSDPA configuration and do not reset order */
   DC_HSDPA_INVALID                         /* SLCE internal use, won't config this enum to UL1 */
}dc_hsdpa_status_E;

/* [R8] Specify that E-DCH transmission is in dedicated state or common state */
typedef enum _edch_transmission_type_E
{
   EDCH_IN_DCH_STATE = 0,                   /* E-DCH allocated in dedicated state */
   EDCH_IN_COMMON_STATE                     /* E-DCH allocated in common state */
}edch_transmission_type_E;

/* [R8] common E-DCH suspend cause. UL1 Internal use */
typedef enum _cedch_suspend_cause_type_E
{
   CEDCH_NONE = 0,            /* no common EDCH */  
   CEDCH_SUSPEND_RLF ,                   /* common EDCH terminate due to RLF */
   CEDCH_SUSPEND_SYNCAA_FAIL,               /* common EDCH terminate due to Sync AA failure */
   CEDCH_SUSPEND_PROCESS_TERMINATION,       /* common EDCH terminate from UMAC */
   CEDCH_SUSPEND_PREAMBLE,               /* common EDCH terminate when AI result has not been received by UL1C */
   CEDCH_SUSPEND_CHANNEL_RELEASE         /* common EDCH terminate due to channel release */   
}cedch_suspend_cause_type_E;

/* [R8] Transport channel type in random access procedure */
typedef enum _cell_fach_ul_trch_type_E
{
   CELL_FACH_UL_TRCH_TYPE_RACH = 0,         /* random access attemp for RACH transmission */
   CELL_FACH_UL_TRCH_TYPE_EDCH              /* random access attemp for E-DCH transmission */
}cell_fach_ul_trch_type_E;
#endif /* __UMTS_R8__ */


#ifdef __UMTS_R7__
typedef struct _hs_scch_less_info_T
{
   hs_scch_less_status_E  hs_scch_less_status;             /* HS-SCCH less mode control flag */
   kal_uint8              hs_scch_less_hspdsch_code_index; /* [Range] Integer(1..15) Index of the first HS-PDSCH code */
   hs_tb_size_list_T      hs_scch_less_tb_size_list[4];    /* 1..<maxHSSCCHLessTrBlk > maxHSSCCHLessTrBlk = 4 */
} hs_scch_less_info_T;

typedef struct _hs_fach_pch_rl_info_T
{
   kal_uint16      dl_freq;                            /* DL UARFCN */
   kal_int32      tm;                                 /* LST to Cell boundary. 0 ~ 38044*8-1 */ 
   kal_int16      off;                                /* Frame # offset to LST. 0 ~ 4095 */
   kal_uint16      psc;                    /* Primary scrambling code */
   kal_bool      sttd;                   /* Indicate if STTD is used for P-CPICH for this RL */
                                             /* If the value of tm is not equal to -1, UL1 will use this value */
                                             /* If the value of tm is equal to -1, UL1 will not use this value */
   kal_int16      rscp;                      /* Serving cell RSCP. Range: -464 ~ -100 means (-116 ~ -25 )dBm in 0.25 dB step*/											 
} hs_fach_pch_rl_info_T;

typedef struct _hs_dtx_drx_timing_info_T 
{
   enabling_delay_E      ED;            /* Time threshold the UE waits until enabling a new timing pattern for DTX/ DRX operation. Uint is radio frame. */
   kal_uint8      ue_dtx_drx_offset;            /* [Range]: 0~159 Units of subframes. Offset of the DTX and DRX cycles at the given TTI.  */
} hs_dtx_drx_timing_info_T;

typedef struct _hs_dtx_param_T 
{
   kal_bool      ue_dtx_on;            /* DTX operation enable/ disable  */
   kal_bool      tti_change;            /* E-DCH TTI is change to 2ms->10ms or 10ms->2ms */
   kal_uint8      ue_dtx_cycle1;            /* DPCCH activity pattern.(1, 5, 10, 20 subframes for 10 ms TTI; 1, 4, 5, 8, 10, 16, 20 subframes for 2 ms TTI) */ 
   kal_uint8      ue_dtx_cycle2;            /* DPCCH activity pattern.(5, 10, 20, 40, 80, 160 subframes for 10 ms TTI;4, 5, 8, 10, 16, 20, 32, 40, 64, 80, 128, 160 subframes for 2 ms TTI) */
   ue_dtx_cycle2_inactivity_threshold_E      cycle2_inactivity_threshold;            /* When to activate the UE DTX cycle 2 after the last uplink data transmission */
   ue_dtx_long_preamble_length_E      preamble_length;            /* Uplink preamble length. Units of slots.Default value is 2 slots */
   cqi_dtx_timer_E      timer_length;            /* Number of subframes after an HS-DSCH reception during which the CQI reports have higher priority than the DTX pattern and are transmitted according to the regular CQI pattern */
   ue_dpcch_burst_E      dpcch_burst1;            /* Length of DPCCH transmission when UE DTX cycle 1 is active Units of sub-frames */
   ue_dpcch_burst_E	 dpcch_burst2;            /* Length of DPCCH transmission when UE DTX cycle 2 is active Units of sub-frames */

   kal_uint8      mac_dtx_cycle;            /* Pattern of time instances where the start of uplink E-DCH transmission after inactivity is allowed.(5, 10, 20 subframes for 10 ms TTI; 1, 4, 5, 8, 10, 16, 20 subframes for 2 ms TTI */
   mac_inactivity_threshold_E      mac_inactivity_threshold;            /* E-DCH inactivity time after which the UE can start E-DCH transmission only at given time. */         	
} hs_dtx_param_T;

typedef struct _hs_drx_param_T 
{
   kal_bool      ue_drx_on;            /* DRX operation enable/ disable */
   ue_drx_cycle_E      drx_cycle_length;            /* HS-SCCH reception pattern, i.e. how often UE has to monitor HSSCCH. */ 
   ue_drx_cycle_inactivity_threshold_E      drx_cycle_inactivity_threshold;            /* Number of subframes after downlink activity where UE has to continuously monitor HS-SCCH. Units of subframes */
   ue_grantMonitoring_inactivity_threshold_E      grantMonitoring_inactivity_threshold;            /* Number of subframes after uplink activity when UE has to continue to monitor E-AGCH/E-RGCH. Units of E-DCH TTIs. */   
   kal_bool      ue_drx_grantMonitoring;            /* whether the UE is required to monitor E-AGCH/E-RGCH when they overlap with the start of an HS-SCCH reception as defined in the HS-SCCH reception pattern */
} hs_drx_param_T;

typedef struct _hs_dtx_drx_info_T 
{
   dtx_drx_status_E      status;
   hs_dtx_drx_timing_info_T      timing;
   hs_dtx_param_T      hs_dtx_param;	
   hs_drx_param_T      hs_drx_param;	
} hs_dtx_drx_info_T;

typedef struct _hs_cell_pch_state_info_T 
{
#ifdef UL1_PHASE3_TEST
   kal_bool      bcch_h_rnti_valid;            /* If bcch_h_rnti_valid = TRUE, UL1 need to receive BCCH over HS-DSCH. Otherwise, UL1 does not need to receive BCCH over HS-DSCH.  */
   kal_uint16      bcch_h_rnti;            /* BCCH specific H-RNTI */
#else
//   kal_bool      bcch_h_rnti_valid;            /* If bcch_h_rnti_valid = TRUE, UL1 need to receive BCCH over HS-DSCH. Otherwise, UL1 does not need to receive BCCH over HS-DSCH.  */
//   kal_uint16      bcch_h_rnti;            /* BCCH specific H-RNTI */
#endif
   pich_info_T      pich_info;
   kal_uint8      pcch_hspdsch_ovsf;           /* [Range] Integer (0..15) HS-PDSCH channel associated with the PICH for HSSCCH less PAGING TYPE 1 message transmission. */
   kal_uint8      num_of_pcch_trans;            /* [Range] Integer (1..5) number of subframes used to transmit the PAGING TYPE 1. */
   kal_int8      pcch_tb_size_index[2];            /* [Range] Integer (1..32). -1 if this is invalid. Index of value range 1 to 32 of the MAC-ehs transport block size as described in appendix A of 25.321. */
   hs_fach_pch_rl_info_T      fach_pch_rl_info;   
} hs_cell_pch_state_info_T;

typedef struct _hs_cell_fach_state_info_T 
{
#ifdef UL1_PHASE3_TEST
   kal_bool      bcch_h_rnti_valid;            /* If bcch_h_rnti_valid = TRUE, UL1 need to receive BCCH over HS-DSCH. Otherwise, UL1 does not need to receive BCCH over HS-DSCH.  */
   kal_uint16      bcch_h_rnti;            /* BCCH specific H-RNTI */
#else
//   kal_bool      bcch_h_rnti_valid;            /* If bcch_h_rnti_valid = TRUE, UL1 need to receive BCCH over HS-DSCH. Otherwise, UL1 does not need to receive BCCH over HS-DSCH.  */
//   kal_uint16      bcch_h_rnti;            /* BCCH specific H-RNTI */
#endif
   hs_fach_pch_rl_info_T      fach_pch_rl_info; 	
} hs_cell_fach_state_info_T;

typedef struct _hs_cell_dch_state_info_T 
{
   kal_bool      dl_64QAM_on;            /* 64QAM enable/disable */
   hs_tbsize_table_E      hsdsch_tbsize_table;            /* If this IE is present, octet aligned table [25.321] is used, else bit aligned table [25.321] is used. 
                                                             In DCH state, this field is assigned by SLCE. Otherthan DCH state, UL1 should use octet-aligned table by itself.*/	
} hs_cell_dch_state_info_T;

typedef union _hspdsch_state_info_T
{
   hs_cell_pch_state_info_T      cell_pch;            /* The parameters in CELL_PCH or URA state. */
   hs_cell_fach_state_info_T      cell_fach;            /* The parameters in CELL_FACH or IDLE_FAC state. */
   hs_cell_dch_state_info_T      cell_dch;            /* The parameters in CELL_DCH state. */
}hspdsch_state_info_T;

#ifdef __UMTS_R8__
typedef struct _hs_cell_fach_drx_T
{
   kal_bool interrupt_by_hsdsch;                        /* TRUE : the DRX operation can be interrupted by HS-DSCH data.
                                                         * FALSE: the DRX operation cannot be interrupted by HS-DSCH data. */
   hs_cell_fach_drx_status_E hs_cell_fach_drx_status;   /* enhanced CELL_FACH DRX status */
   kal_uint8                 timer_length;              /* inactivity timer to start HS CELL_FACH DRX (10/20/40/80 frames)*/
   kal_uint8                 drx_cycle_length;          /* HS CELL_FACH DRX cycle length (4/8/16/32 frames) */
   kal_uint8                 drx_burst_length;          /* the period within the HS DRX cycle that the UE continuously receive HS-DSCH (1/2/4/8/16 frames) */
   
}hs_cell_fach_drx_T;

typedef struct _secondary_hspdsch_info_T
{
   kal_bool          dl_64QAM_on;           /* If 64QAM supported in secondary HS-DSCH */
   kal_uint16        h_rnti;                /* h_rnti to decode secondary HS-DSCH receiving */
   hs_tbsize_table_E hsdsch_tbsize_table;   /* If dl_64QAM_on = KAL_TRUE, hsdsch_tbsize_table should be OCTET_ALIGNED. */
}secondary_hspdsch_info_T;

typedef struct _dc_hsdpa_info_T
{
   kal_uint8                modify_field;     /* Bit 0: hs_scch_info_T
                                               * Bit 1: secondary_hspdsch_info_T
                                               * Bit 2: psc
                                               * Bit 3: meas_po
                                               * Bit 4: dl_freq
                                               * Bit 5: sttd  */
   dc_hsdpa_status_E        dc_hsdpa_status;  /* variable to control UL1 DC HS-DSCH receiving */
   hs_scch_info_T           hs_scch_info;     /* Secondary HS-SCCH info. */
   secondary_hspdsch_info_T sec_h_info;       /* Secondary HS-PDSCH info. */
   kal_uint16	             psc;              /* Primary scrambling code used in secondary H cell*/
   kal_int8                 meas_po;          /* Measurement power offset, step = half dB. Range = -12~26 (-6dB~13dB)*/
   kal_uint16               dl_freq;          /* DL UARFCN, 0~16383*/
   kal_bool                 sttd;             /* TRUE: STTD is used for P-CPICH of the secondary cell
                                               * FALSE: STTD is not used for P-CPICH of the secondary cell.*/
}dc_hsdpa_info_T;

typedef struct _dl_pc_info_T                /* DL power control information used for common E-DCH */
{
   kal_uint8   tpc_target;                  /* range: 1~10, the actual TPC command error rate target is tpc_target/100 */
   kal_uint8   dpc_mode;                    /*DL Power control mode. 0 or 1 or 2. In current spec,  SLCE will always fix this field by 0 for common E-DCH. */
   kal_uint8   fdpch_slot_format;           /* range: 0~9. In current spec, SLCE will always fix this field by 0 for common E-DCH. */
}dl_pc_info_T;

typedef struct _ul_dpch_code_info_T         /* UL DPCH information used for common E-DCH transmission */
{
   sc_type_E   sc_type;                     /* short type or long type scrambling code */
   kal_uint32  sc_code;                     /* 0 ~ 16777215 */
}ul_dpch_code_info_T;

typedef struct _edch_resource_list_T
{
   kal_uint8            s_offset;           /* symbol offset. range: 0~9 */
   kal_uint8            fdpch_ovsf;         /* 0 ~ 255 */
   kal_uint8            ehirgch_ovsf;       /* ovsf code for receiving E-HICH and E-RGCH in common E-DCH transmission */
   kal_uint8            hich_signature_seq; /* E-HICH signature sequence in common E-DCH transmission [Range: 0~39] */
   kal_uint8            rgch_signature_seq; /* E-RGCH signature sequence in common E-DCH transmission [Range: 0~39, 0xff means invalid. No need to decode E-RGCH] */
   ul_dpch_code_info_T  ul_dpch_code_info;  /* UL DPCH information used for common E-DCH transmission */
}edch_resource_list_T;

typedef struct _common_edch_info_T
{
   kal_uint8            add_tran_back_off;       /* 0 ~ 15, unit is TTI */
   kal_uint8            edch_resource_num;       /* 1~32 */
   edch_resource_list_T edch_resource_list[32];  /* common RLs for E-DCH transmission */
   ul_pc_info_T         ul_pc;                   /* ul power control info. */
}common_edch_info_T;

typedef struct _edch_specific_info_T
{
   kal_bool e_ai_ind;                       /* TRUE: E-AI should be used. FALSE: E-AI should not be used. */
   kal_int8 po_p_e;                         /* -5 ~ 10 dB, power offset between last TX preamble and initial DPCCH */
}edch_specific_info_T;


typedef struct
{
   kal_bool   d_hrnti_valid; 
   kal_uint16 d_hrnti;/*dH-RNTI*/ 

   kal_bool   c_hrnti_valid;
   kal_uint16 c_hrnti;/*cH-RNTI*/

   kal_bool   b_hrnti_valid;
   kal_uint16 b_hrnti;/*cH-RNTI*/ 

} hs_hrnti_info_T;

#endif /* __UMTS_R8__ */
#endif /* __UMTS_R7__ */

#endif
